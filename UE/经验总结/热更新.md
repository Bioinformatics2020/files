# 热更新

## 资源热更新设计思考

### 理论基础

- UE可以分为代码文件与资源文件两部分
- 蓝图文件属于资源文件
- 资源文件可以在运行时动态加载与卸载
- 卸载资源，并在另一个pak文件中重新加载资源就可以完成热更新
- UE支持分块打包，可以只更新一部分资源

### 第0阶段  功能预研

检查新版本
卸载旧包
挂载新版本的包
卸载资产
垃圾回收
加载资产

### 第一阶段 热更新的基本功能

**开发时资源分包**

1. 提供一个简单直接的Chunk分包方案
2. 提供基础版(大版本)与更新版(小版本)的发布方法

**服务器资源管理**

暂时不必考虑在服务器进行版本管理，目前纯手动管理

**启动时缓存的Pak加载**

1. 热更新后需要保证Pak文件可以在重启之后正常使用

2. 运行时记录每个Pak与模块的加载情况，用于后续卸载与重装流程

**后台版本比对功能(安卓侧)**

1. 查询最新的版本
	使用明文的manifest文件记录当前缓存的Pak，ChunkID，以及对应的版本号。
	定时触发下载最新manifest的事件，下载完成后进行比较，确定需要下载哪些Pak
2. 下载最新Pak
	下载最新Pak，下载完成后保存到本地
	触发更新事件发送到UE程序

**Pak文件加载与挂载功能**

1. 响应更新事件、读取配置文件并保存到Content目录
2. 确认哪些Pak需要卸载并重新挂载
3. 完成Pak重新挂载
4. 更新版本信息

**资产重新加载**

1. 确认哪些模块需要重新加载
2. 按照模块依赖关系逐一卸载模块
3. 触发GC
4. 重新加载根模块，并要求根模块自动加载子模块

### 第二阶段 资源引用检查、扩展Patch包、资产校验、热更新进度

**开发时资源分包**

1. 封装UE的打包流程，做到一键打出基础包，快捷的打出更新包，特殊配置打出补丁包
2. 打出的包需要携带版本信息，并使用特定的文件夹存储
3. 需要在编辑器下显示每一个Chunk内包含的资产，以及输出资产到Chunk的引用路径
4. Pak打包完成之后添加Hash校验码，任意一个Pak校验失败则不要更新
5. 打出Patch包

**服务器资源管理**

使用一个文件夹模拟服务器资源

**后台版本比对功能(安卓侧)**

UE提供一个版本比对与Pak文件复制的功能用于调试

**Pak文件加载与挂载功能**

1. Pak资源校验
2. 挂载Patch包
3. Pak包本地备份与异常状态恢复，如果热更新出一个致命bug，要保证可以版本回退
4. 处理正在加载的资源被更新的情况

**资产重新加载**

1. 管理模块重新加载进度
2. 处理正在加载的模块被更新的情况
3. 提供热更新进度条

### 第三阶段 功能优化

- 优化编辑器工具为编辑器扩展插件

- Pak异步拷贝与校验
- 将对引擎的修改剥离到项目或插件中
- Chunk diff工具
- 基于Git工具检测哪些目录或资产发生变动
- mp4、config等特殊资产热更新
- 集成HotPatch包体优化策略
- 引擎多版本适配
- ShaderLib热更新

### 补充资料：

ChunkDownloader提供基础的服务器部署与Pak下载更新方案：
https://docs.unrealengine.com/4.27/en-US/SharingAndReleasing/Patching/ChunkDownloader/

HotPatcher提供强大的版本管理与Pak打包工具：
https://imzlp.com/posts/17590/

Pak结构：
https://zhuanlan.zhihu.com/p/333857439

## 第0阶段  Demo功能实现

**debug**

```C++
// 获取 pak 文件管理器
FPakPlatformFile* PakFile = (FPakPlatformFile*)FPlatformFileManager::Get().FindPlatformFile(TEXT("PakFile"));

// 如果 PakFile 不为 nullptr，则说明平台文件支持 pak 文件处理
	if (PakFile)
	{
		// 获取并遍历所有已挂载的 pak 文件名
		TArray<FString> MountedPakFilenames;
		PakFile->GetMountedPakFilenames(MountedPakFilenames);
		// 打印每个已挂载的 pak 文件名
		for (const FString& PakFilename : MountedPakFilenames)
		{
			UE_LOG(LogHotUpdateTool, Warning, TEXT("Mounted Pak Filename: %s"), *PakFilename);
		}
    }
```

**检查新版本**

```c++
//在指定目录下查找最新的Pak文件
TArray<FString> Result;
IFileManager::Get().FindFiles(Result, *(LoadPaks+"*"), true, false);
```

**卸载旧包**

```c++
bool bUnMountOK = FCoreDelegates::OnUnmountPak.Execute(PakPathOnDisk);
if (!bUnMountOK)
{
   UE_LOG(LogHotUpdateDemo, Warning, TEXT("OnUnMountPak error %s"), *PakPathOnDisk);
}
```

**挂载新版本的包**

```c++
//按照指定的优先级挂载新包
bool bMountOk = FCoreDelegates::OnMountPak.Execute(PakPathOnDisk, PakReadOrder, nullptr);
if (bMountOk)
{
   //将包保存到本地目录，下次启动时直接加载
   const FString SavedPaks = FPaths::ProjectSavedDir() / TEXT("PakCache/");
   int CopyResult =IFileManager::Get().Copy(*(SavedPaks + PakName), *PakPathOnDisk);
   UE_LOG(LogHotUpdateDemo, Log, TEXT("OnMountPak ok, CopyResult %d. %s"), CopyResult, *PakPathOnDisk);
   //包的优先级自动加一，保证即使包名未更新或旧包未卸载，后挂载的包始终优先级更高
   PakReadOrder += 1;
}
```

**卸载资产**

```c++
//对所有资产进行清理，这里仅演示一个
CarActor->Destroy();
CarActor = nullptr;
```

**垃圾回收**

```c++
//必须进行GC之后包体资源才会从内存释放，在这之后加载资源才会从硬盘加载
CollectGarbage(RF_NoFlags);
```

**加载资产**

```c++
//重新创建所有更新的资产，这里仅演示一个
UClass* CarClass = CarActorSoftClass.LoadSynchronous();//加载资产
CarActor=GetWorld()->SpawnActor(CarClass,&Location,&Rotation);//创建对象
```

## 后续阶段参考如下插件