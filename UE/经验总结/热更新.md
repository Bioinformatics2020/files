# 热更新

## 设计思考

### 第0阶段  Demo

检查新版本
卸载旧包
挂载新版本的包
卸载资产
垃圾回收
加载资产

### 第一阶段 热更新的基本功能

**服务器资源管理**

**启动时缓存的Pak加载**

**版本比对功能**

1. 查询最新的版本(安卓侧)
	使用明文的manifest文件记录当前缓存的Pak，ChunkID，以及对应的版本号。
	定时触发下载最新manifest的事件，下载完成后进行比较，确定需要下载哪些Pak
2. 下载最新Pak(下载功能调用安卓)
	下载最新Pak，下载完成后保存到本地
	触发更新事件发送到UE

**Pak文件加载与挂载功能**

1. 响应更新事件、读取最新文件并保存到Save目录、Pak挂载，触发重新挂载事件
	创建一个UE侧的Pak管理系统去在其它线程实现
3. 销毁旧资源对象
4. 资源依赖关系处理、资源数据处理
5. 重新加载新对象

### 第二阶段 详细的热更新系统考虑事项

- 便捷的服务器部署方案
- 考虑什么情况使用Pak包或Pitch包
- 更安全更冗余的下载与更新系统
- 完善的版本管理与发布系统
- 便捷的Pak打包流程
- 架构更清晰的资产重新加载系统
- 扩展热更新MP4、config等资产
- 更通用的调试系统以及对应的可视化界面

### 补充资料：

ChunkDownloader提供基础的服务器部署与Pak下载更新方案：
https://docs.unrealengine.com/4.27/en-US/SharingAndReleasing/Patching/ChunkDownloader/

HotPatcher提供强大的版本管理与Pak打包工具：
https://imzlp.com/posts/17590/

Pak结构：
https://zhuanlan.zhihu.com/p/333857439

## 第0阶段  Demo功能实现

**检查新版本**

```c++
//在指定目录下查找最新的Pak文件
TArray<FString> Result;
IFileManager::Get().FindFiles(Result, *(LoadPaks+"*"), true, false);
```

**卸载旧包**

```c++
bool bUnMountOK = FCoreDelegates::OnUnmountPak.Execute(PakPathOnDisk);
if (!bUnMountOK)
{
   UE_LOG(LogHotUpdateDemo, Warning, TEXT("OnUnMountPak error %s"), *PakPathOnDisk);
}
```

**挂载新版本的包**

```c++
//按照指定的优先级挂载新包
bool bMountOk = FCoreDelegates::OnMountPak.Execute(PakPathOnDisk, PakReadOrder, nullptr);
if (bMountOk)
{
   //将包保存到本地目录，下次启动时直接加载
   const FString SavedPaks = FPaths::ProjectSavedDir() / TEXT("PakCache/");
   int CopyResult =IFileManager::Get().Copy(*(SavedPaks + PakName), *PakPathOnDisk);
   UE_LOG(LogHotUpdateDemo, Log, TEXT("OnMountPak ok, CopyResult %d. %s"), CopyResult, *PakPathOnDisk);
   //包的优先级自动加一，保证即使包名未更新或旧包未卸载，后挂载的包始终优先级更高
   PakReadOrder += 1;
}
```

**卸载资产**

```c++
//对所有资产进行清理，这里仅演示一个
CarActor->Destroy();
CarActor = nullptr;
```

**垃圾回收**

```c++
//必须进行GC之后包体资源才会从内存释放，在这之后加载资源才会从硬盘加载
CollectGarbage(RF_NoFlags);
```

**加载资产**

```c++
//重新创建所有更新的资产，这里仅演示一个
UClass* CarClass = CarActorSoftClass.LoadSynchronous();//加载资产
CarActor=GetWorld()->SpawnActor(CarClass,&Location,&Rotation);//创建对象
```

